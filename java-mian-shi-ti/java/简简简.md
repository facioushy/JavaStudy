**TCP保证传输可靠：**校验和；编号；流量控制；拥塞控制；超时重传；三次、四次

**HTTP 1.1 1.0：**长连接，错误状态码，缓存控制策略，带宽优化(range)

**HTTP 2.0：**二进制格式；首部压缩；服务器推送；多路复用

**(非)对称加密算法：**（RAS DSA） DES AES

**输入URL后的过程：**1. DNS解析；2. 发送HTTP；3. 传输层，TCP封装HTTP，加入端口；4. 网络层，IP封装成数据包，ARP光播到对方主机得到MAC地址；5. 链路层，增加首尾部封装成MAC帧，建立TCP连接。收到后识别首尾部，逐层返回；6. 返回资源；7. 断开连接，浏览器渲染界面

**Reactor：**单线程，单reactor多线程，多reactor多线程

**ACID：**原子性(undo)，一致性(undo)，隔离性(MVCC，锁)，持久性(redo)

**数据库隔离级别：**未提交读，已提交读，可重复读(默认)，串行化

**查询语句流程：**验证用户名密码，检查语法，优化SQL语句及执行顺序，权限校验

**更新语句：**UPDATE t set k = k+1 WHERE id=5; 获取记录；从B+树搜索记录；进行+1操作；更新记录到内存中，写入到redo log，状态置为prepare；写入binlog；提交事务，redo log置为commit

**索引创建原则：**1. 最适合的索引在where子列中；2. 索引基数越大效果越好；3. 避免过多索引； 4. 主键尽可能短

**mysql解决死锁：**1. 发生事务等待就回滚；2. 等待时间阈值； 3. wait for graph(锁的信息链表和事务等待链表)

**数据库三范式：**1. 所有字段都是不可分解的原子值；2. 属性依赖于主键； 3. 不存在依赖传递

**进程通信方式：**管道；有名管道；信号量；信号；消息队列；套接字；共享内存；

**线程同步方式：**信号量；互斥量；notify/wait

**进程调度算法：**先到先服务；短作业优先；最短剩余时间；时间片轮转；多级反馈队列调度；优先级调度

**页面置换算法：**先进先出；最久未使用；最少使用；最佳页面置换算法

**用户态到内核态：**系统调度；异常；中断

**银行家算法：**当资源池中剩余的可利用资源>=线程需要的资源时，可分配给内存；线程可请求资源，但是请求的资源总数不能超过资源池中剩余的可利用资源；当线程池中的资源暂时不满足当前的线程所需时，将此线程先暂时搁置，先将资源分配给能够满足需求的其他线程，等到满足搁置的线程之后，再分配；线程拿到所需要的所有资源后，运行结束后，将自身的所有资源放回资源池中

**僵尸进程：**进程描述符

**jdk动态代理：**编写需要被代理的类和接口；编写代理类，实现InvocationHandle接口，重写invoke()方法；函数动态创建代理类对象，通过代理类对象调用业务方法。无接口用CGLIB

**hashmap 1.7 1.8：**1.7 数组+链表 1.8 大于8会转红黑树；头插 尾插

**concurrenthashmap：**1.7 segment+hashentry+链表 1.8CAS+synchronized + node数组+链表/红黑树

**put流程：**计算hashcode；判断是否需要初始化(hashmap是否为空)；判断桶中有无元素，无则CAS加，有则判断是否正在扩容；如果前两者都不满足，则用synchronized写入数据；如果链表数量大于阈值转为红黑树

**CopyOnWriteArrayList：**底层由数组实现，volatile修饰，修改时复制新数组，写加锁，读不加锁，遍历是用原数组

**进程：**资源分配的最小单位；线程：CPU调度的最小执行单位

**死锁必要条件：**1. 互斥条件；2保持与等待条件；3不可剥夺条件；4循环等待条件

**JMM：**解决原子性(Synchronized) 可见性(VOLATILE) 有序性(Synchronized volatile)

**volatile:** 可见性；防止指令重排；  内存屏障：lock前缀，屏障之后的指令不会出现在屏障之前；强制对缓存的修改立即写入主存；写操作会导致其他CPU中对应的缓存行无效

**reentrantlock和synchronized：**s自动释放锁，java内置关键字，lock手动释放，s不可中断，不知道自己获得了锁，lock可中断，可知，都为非公平锁，lock可实现公平锁，s悲观，l乐观

锁升级：1. 检查是否为当前进程ID，是则为偏向锁；2. 不是锁升级，CAS，新线程通知之前线程暂停，MARKWORD置为空；3. 两线程开始CAS；4. 成功获得资源，失败自旋；5自旋获得资源仍未轻量级锁；6. 失败，进入重量级锁，自旋进程阻塞，等待唤醒

AQS：请求资源空闲，则设为有效的工作线程，并设为锁定状态。若占用，将获取不到锁的线程加入到队列。 state(CAS算法)来表示状态，CLH队列，先进先出

executors类可创建的线程池：单线程化；固定线程数；可定期或延迟执行；多线程同时执行；前两个请求队列长度为max 后两个可创建的线程数量为max

JVM内存划分：堆(存放实例对象)，方法区(静态变量、常量、类信息)，线程(程序计数器，虚拟机栈(局部变量表、动态链接、操作数栈、返回地址)、本地方法栈)

FULL GC条件：1. System.gc()；2. 老年代空间不足；3.空间分配担保失败；4.永久代空间不足；5. CMS过程中进入老年代但是不足 会触发

GC ROOTS：虚拟机栈中 栈帧引用对象；本地方法栈中JNI栈帧引用对象；方法区中常量，静态变量；所有被锁持有的对象

CMS: 并发收集，低停顿。1. 初始标记；2并发标记；3重新标记；4并发清除

G1：标记整理算法，不牺牲吞吐量前提下，实现低停顿垃圾回收。把堆内存划分为多个区域，跟踪这些区域内的垃圾收集进度，在后台维护一个优先级的列表，每次根据所允许的时间优先回收最多垃圾的区域

类加载过程：1. 加载(字节码到二进制流)；2. 验证；3准备(为静态变量、常量赋默认值)；4解析：常量池中的符号引用替换为直接引用；5. 初始化：执行static代码

new一个对象：1. 为对象分配内存；2. 为实例变量赋默认值；3.分配对象头；4.初始化