# JVM篇

## 1.Java的内存结构

![&#x5728;&#x8FD9;&#x91CC;&#x63D2;&#x5165;&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://img-blog.csdnimg.cn/2021052417245177.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70)

### 1. 程序计数器

线程私有，一块较小的内存空间，**程序计数器用于保存 JVM 中下一条所要执行的字节码指令的地址**

### 2. 虚拟机栈

线程私有，它的生命周期与线程相同。**虚拟机栈是Java方法执行的内存模型**，每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。方法调用&lt;=&gt;入栈，完成&lt;=&gt;出栈。

* 每个栈由多个**栈帧**\(Frame\) 组成，对应着**每个方法运行时所占用的内存。**
* 每个线程只能有**一个活动栈帧**，对应着**当前正在执行的方法**，当方法执行时压入栈，方法执行完毕后弹出栈。
* **方法体中的引用变量和基本类型的变量都在栈上，其他都在堆上**。

### 3. 本地方法栈

线程私有，本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 _Native_ 方法服务。

### 4. 堆

线程共享。Java虚拟机所管理的内存中最大的一块。唯一目的就是**存放对象实例**，**几乎所有的对象实例都在这里分配内存**。

* 通过`new`关键字**创建的对象**都会被放在堆内存。
* **方法体中的引用变量和基本类型的变量都在栈上，其他都在堆上**。
* Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“**GC 堆**”（Garbage）。

### 5. 方法区

线程共享。方法区用于存储已被虚拟机加载的 _类信息（构造方法、接口定义）、常量、静态变量、即时编译器编译后的代码（字节码）_等数据。

* **注意：方法区时一种规范，而永久代和元空间是它的2种实现方式**。

### 6. 运行时常量池

* **常量池**：可以看做是一张表，虚拟机指令根据这张常量表找到要执行的 _类名，方法名，参数类型、字面量_ 等信息。
  * 常量池是`*.class`文件中的，当该**类被加载以后**，它的常量池信息就会**放入运行时常量池**，并把里面的**符号地址变为真实内存地址**。
* **运行时常量池**：是方法区的一部分。

```java
String str = new String("hello");
```

## 2. JVM垃圾回收是否涉及栈内存

* **不需要**。因为虚拟机栈中是由一个个栈帧组成的，在方法执行完毕后，对应的栈帧就会被弹出栈。所以无需通过垃圾回收机制去回收内存。

## 3. 虚拟机栈内存的分配越大越好吗？

* **不是**。因为**物理内存是一定的**，栈内存越大，可以支持更多的递归调用，但是可执行的线程数就会越少。

## 4. 从JVM的角度分析，方法内的局部变量是否是线程安全的

局部变量如果是静态的可以被多个线程共享，那么就存在线程安全问题。如果是非静态的只存在于某个方法作用范围内，被线程私有，那么就是线程安全的！

* 如果方法内**局部变量没有逃离方法的作用范围**，则是**线程安全**的。
* 如果**局部变量引用了对象**，并**逃离了方法的作用范围**，则需要考虑线程安全问题。

## 5. 虚拟机栈内存溢出的情况

* 1. 虚拟机栈中，**栈帧过多**（方法无限递归）导致栈内存溢出，这种情况比较**常见**！
* 1. 每个栈帧**所占用内存过大**\(某个/某几个栈帧内存直接超过虚拟机栈最大内存\)，这种情况比较**少见**！

## 6. 说一下JVM运行时数据区方法区的演进

1.6：由Class、ClassLoader、常量池\(包括StringTable\) 组成。静态变量就存放在永久代\(方法区\)上

1.7：仍有永久代，但已经逐步 " 去永久代 "，StringTable、静态变量从永久代移除，保存在堆中。

1.8：方法区交给本地内存管理，而脱离了JVM，由元空间实现\(**元空间不再使用堆的内存，而是使用本地内存，即操作系统的内存**\)，由Class、ClassLoader、常量池\(StringTable 被移到了堆中管理\) 组成。静态变量、StringTable 存放在堆中！

永久代缺点：

* ① 字符串常量池存在于永久代中，在大量使用字符串的情况下，非常容易出现OOM的异常。
* ② J**VM加载的class的总数，方法的大小**等都很难确定，因此对永久代大小的指定难以确定。太小的永久代容易导致永久代内存溢出，太大的永久代则容易导致虚拟机内存紧张，空间浪费。
* ③ 永久代进行调优很困难：方法区的垃圾收集主要回收两部分，**常量池中废弃的常量**和不**再使用的类**。而不再使用的类或类的加载器回收比较复杂，_FULL GC_ 的时间长。

## 7. Java虚拟机中有哪些类加载器

| 名称 | 加载哪的类 | 说明 |
| :--- | :--- | :--- |
| Bootstrap ClassLoader\(启动类加载器\) | JAVA\_HOME/jre/lib | 无法直接访问 |
| Extension ClassLoader\(扩展类加载器\) | JAVA\_HOME/jre/lib/ext | 上级为 Bootstrap，显示为 null |
| Application ClassLoader\(应用程序类加载器\) | classpath | 上级为 Extension |
| 自定义类加载器 | 自定义 | 上级为 Application |

类加载器的优先级（由高到低）：**启动类加载器 -&gt; 扩展类加载器 -&gt; 应用程序类加载器 -&gt; 自定义类加载器**。

## 8. 类加载过程

类加载的过程包括：**加载、验证、准备、解析、初始化**。其中验证、准备、解析统称为**连接**。

* **加载**：通过一个类的全限定名来获取定义此类的二进制字节流，在内存中生成一个代表这个类的`java.lang.Class`对象。
* **验证**：确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。
* **准备**：为静态变量分配内存并设置静态变量初始值，这里所说的初始值“**通常情况**”下是数据类型的零值。
* **解析**：将常量池内的符号引用替换为直接引用。
* **初始化**：到了初始化阶段，才真正开始执行类中定义的 Java 初始化程序代码。主要是静态变量赋值动作和静态语句块（`static{}`）中的语句。

## 9. 双亲委派机制

![&#x5728;&#x8FD9;&#x91CC;&#x63D2;&#x5165;&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://img-blog.csdnimg.cn/20210525185609843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70)

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

好处：

**避免重复加载 + 避免核心类篡改**

* 采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父加载器已经加载了该类时，就没有必要子加载器再加载一次。
* 其次是考虑到安全因素，java 核心 api 中定义类型不会被随意替换，假设通过网络传递一个名为 java.lang.Integer 的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的 java.lang.Integer，而直接返回已加载过的 Integer.class，这样便可以防止核心API库被随意篡改。

## 10. 虚拟机栈和堆的区别

① 物理地址方面的区别：

* **堆** 的物理地址分配对对象是不连续的。因此性能慢些。
* **虚拟机栈** 使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。

② 内存分配方面的区别：

* **堆** 因为是不连续的，所以分配的内存是在`运行期`确认的，因此大小不固定。一般堆大小远远大于虚拟机栈。
* **虚拟机栈** 是连续的，所以分配的内存大小要在`编译期`就确认，大小是固定的。

③ 存放的内容方面的区别：

* **堆** 存放的是对象的实例和数组。因此该区更关注的是数据的存储。
* **虚拟机栈** 存放的是局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。

**注**：静态变量放在方法区，而静态的对象还是放在堆。

④ 线程共享方面的区别：

* **堆** 对于整个应用程序都是共享、可见的。
* **虚拟机栈** 只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。

## 11. java中的五种引用

### 1. 强引用

* 只要沿着 _GC Root_ 的引用链能够找到该对象，就不会被垃圾回收；只有当 _GC Root_ **都不引用**该对象时，才会回收**强引用**对象。

### 2. 软引用

如果仅有软引用引用某个对象时，在垃圾回收后，内存仍不足时会再次触发垃圾回收，回收软引用对象。

### 3. 弱引用

* 弱引用是较软引用更低一级的引用，如果仅有弱引用引用某个对象，在垃圾回收时，**无论内存是否充足**，都会回收弱引用所引用的对象。

### 4. 虚引用

* 虚引用必须配合引用队列使用，主要配合 ByteBuffer 使用，引用对象被回收时，会将虚引用入队，然后调用虚引用相关方法（`Unsafe.freeMemory()`）释放直接内存。

### 5. 终结器引用

所有的类都继承自Object 类，Object 类有一个finalize\(\)方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中（被引用对象暂时没有被回收），然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize\(\)方法。调用以后，该对象就可以被垃圾回收了。

### 引用队列

当一个引用（软引用、弱引用）关联到了一个引用队列后，当这个引用所引用的对象要被垃圾回收时，就会将它加入到所关联的引用队列中，所以判断一个引用对象是否已经被回收的一个现象就是，这个对象的引用是否被加入到了它所关联的引用队列。

引用队列就是一个对引用的回收机制，当软引用或弱引用所包装的对象为 `null` 或被回收时，这个引用也就不在具有价值，引用队列就是清除掉这部分引用的一种回收机制。

* 软引用和弱引用可以配合引用队列\(也可以不配合\)：在**弱引用**和**虚引用**所引用的对象被回收以后，会将这些引用放入引用队列中，方便一起回收这些软/弱引用对象。
* 虚引用和终结器引用**必须配合引用队列**： **虚引用**和**终结器引用**在使用时会关联一个引用队列。

## 12. JVM是如何判断对象可以被回收的？判断对象回收的算法

### 1. 引用计数法

* 如果一个对象被其他变量所引用，则让该对象的引用计数`+1`，如果该对象被引用 _2_ 次则其引用计数为 _2_，依次类推。
* 某个变量不再引用该对象，则让该对象的引用计数`-1`，当该对象的引用计数变为_0_ 时，则表示该对象没用被其他变量所引用，这时候该对象就可以被作为垃圾进行回收。

**引用计数法弊端**：循环引用时，两个对象的引用计数都为 _1_ ，导致两个对象都无法被释放回收。最终就会造成内存泄漏！

### 2. 可达性分析算法

首先要确定 _GC Root_ \(根对象，就是肯定不会被当成垃圾回收的对象\)

#### 可以作为GC Root的对象

* 虚拟机栈（栈帧中的本地变量表）中引用的对象。
* 方法区中类静态属性引用的对象。
* 方法区中常量引用的对象。
* 本地方法栈中 _Native_ 方法引用的对象。

## 13. JVM垃圾回收算法有哪些？

### 1. 标记清除算法

顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象，然后垃圾收集器根据标识，清除相应的内容，给堆内存腾出相应的空间。

* 这里的腾出内存空间并不是将内存空间的字节清 0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接**覆盖**这段内存。
* 它的主要不足有两个：
  * 一个是效率问题，标记和清除两个过程的效率都不高；
  * 另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

### 2. 标记整理算法

会将不被 _GC Root_ 引用的对象回收，清除其占用的内存空间。然后整理剩余的对象内存空间，可以有效避免因内存碎片而导致的问题，但是牵扯到对象的整理移动，需要消耗一定的时间，所以效率较低。

### 3. 复制算法

* 将内存分为等大小的两个区域，**FROM**和**TO**（TO中为空）。先将被 _GC Root_ 引用的对象从 **FROM** 放入 **TO** 中，再回收不被 _GC Root_ 引用的对象。然后交换 **FROM** 和 **TO**。

**这样也可以避免内存碎片的问题，但是会占用双倍的内存空间**

### 4. 分代收集法

新生代默认的空间占比总空间的 1/3，老生代的默认占比是 2/3。根据不同年代的特点采用最适当的收集算法。

* 在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。

  新生代里有 3 个分区：伊甸园、To 幸存区、From 幸存区，它们的默认占比是 8:1:1。

* 在老年代中，因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记—清理或者标记—整理算法来进行回收。

流程：

1. **长时间使用的对象放在老年代中**（长时间回收一次，回收花费时间久），**用完即可丢弃的对象放在新生代中**（频繁需要回收，回收速度相对较快）：
2. 新创建的对象都被放在了**新生代的伊甸园**\(Eden\)中;
3. 当Eden中存放对象过多时，内存不够，出发Minor GC
4. _Minor GC_ 会将**伊甸园和幸存区FROM**仍需要存活的对象**先**复制到 **幸存区 TO**中， 并让其**寿命加1**，再**交换FROM和TO**。不需要的对象清除。
5. 再次创建对象，若新生代的伊甸园又满了，则会再次触发 Minor GC（会触发 Stop The World， 暂停其他用户线程，只让垃圾回收线程工作），这时不仅会回收伊甸园中的垃圾，还会回收幸存区中的垃圾，再将活跃对象复制到幸存区TO中。回收以后会交换两个幸存区，并让幸存区中的对象寿命加1！\(如果幸存区的对象的寿命大于某个阈值，就会被放入老年代\)
6. 如果新生代老年代中的内存都满了，就会先触发 _Minor Gc_，再触发 **Full GC**，扫描**新生代和老年代中**所有不再使用的对象并回收；

## 14. JVM垃圾回收机制

### Young GC \(Minor GC\)

当新生代中的 Eden\(伊甸园\) 区没有足够空间进行分配时会触发 Young GC。 Young GC 其实就是一次 复制垃圾回收算法 将伊甸园和幸存区FROM仍需要存活的对象先复制到 幸存区 TO中， 并让其寿命加1，再交换 FROM和 TO。这时候伊甸园中不需要存活的对象就将其清除。

### Full GC

* 如果新生代老年代中的内存都满了，就会先触发 _Young GC_，再触发 **Full GC**，扫描**新生代和老年代中**所有不再使用的对象并回收。
* `System.gc()` 默认也是触发 _Full GC_。
* _Full FC_ 使用 标记—清理 或者 标记—整理 算法来进行回收。

### 触发条件：

_Young GC_：当新生代中的Eden区没有足够空间进行分配时会触发 _Young GC_。

Full GC：

* 当准备要触发一次 Young GC 时，如果发现统计数据说之前 Young GC 的平均晋升大小比目前老年代剩余的空间大，则不会触发 Young GC 而是转为触发 Full GC。（通常情况）
* 如果有永久代的话，在永久代需要分配空间但已经没有足够空间时，也要触发一次 Full GC。
* System.gc\(\) 默认也是触发 Full GC。
* 空间分配担保失败：何为空间担保：因为eden区容纳不下接下来对象B所需内存的大小，虚拟机将发起一次 Minor GC，GC期间虚拟机又发现之前的对象A无法存入 Survivor 空间，所以只好通过分配担保机制把新生代的对象A提前转移到老年代中去，老年代有足够的内存存放。
* Concurrent Mode Failure：CMS GC过程中有对象进入老年代，老年代不足 会触发

## 15. JVM的垃圾回收器

* **吞吐量**：即CPU用于**运行用户代码的时间**与CPU**总消耗时间**的比值（`吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间`\)），也就是。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是`99%`。

> 垃圾回收器的分类：

* 串行：单线程垃圾收集。
* 吞吐量优先：多线程垃圾收集，**单位时间内**，让STW（stop the world，停掉其他所有工作线程）时间最短。
* 响应时间优先：多线程垃圾收集，**尽可能**让**单次**STW时间变短（尽量不影响其他线程运行）。

![img](https://img-blog.csdnimg.cn/20200104120144820.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

**CMS 收集器**：**老年代并行收集器**

* **以获取最短回收停顿时间为目标的收集器**，具有高并发、低停顿的特点，追求最短GC回收停顿时间。
* CMS 收集器基于**标记-清除算法**实现，会产生内存碎片。

**G1 收集器** ： **Java堆并行收集器**

* G1收集器是 JDK1.7 提供的一个新收集器，G1 收集器基于**标记-整理算法**实现，也就是说不会产生内存碎片。
* 此外，G1 收集器不同于之前的收集器的一个重要特点是：G1回收的范围是整个Java堆\(包括新生代，老年代\)，而其他六种收集器回收的范围仅限于新生代或老年代。

CMS 和 G1 都是属于响应优先的垃圾回收器：**尽可能**让**单次** STW 时间变短（尽量不影响其他线程运行）。

## 16. 分析题a++ + ++a

```java
/**
* 从字节码角度分析 a++ 相关题目
*/
public class Demo3_2 {
    public static void main(String[] args) {
        int a = 10;
        int b = a++ + ++a + a--;
        System.out.println(a);// 11
        System.out.println(b);// 34
    }
}
```

* `iinc` 指令是直接在局部变量桶位（slot）上进行运算。
* `iload`指令是用于读取变量
* `a++` 和 `++a` 的区别是先执行 `iload`还是 先执行`iinc`。`a++`是先 `iload`再`iinc`，`++a`相反。

①bipush 10 操作是把a = 10 放入操作数栈：

![img](https://img-blog.csdnimg.cn/20210501203800387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70)

② istore 1 操作，把操作数栈中的10弹出，放入到局部变量表的槽位1中：

![img](https://img-blog.csdnimg.cn/20210501203828137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70)

③ 接下来执行a++操作，我们上边提前说明了，a++是先执行iload读取，再执行iinc 加 1

iload 1 将 变量a=10，读取到操作数栈stack中：

![img](https://img-blog.csdnimg.cn/20210501204129476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70)

执行iinc指令，在局部变量表上对a进行 +1 操作，这时候 a 为11：

![img](https://img-blog.csdnimg.cn/20210501203848446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70)

④ 下面执行++a操作，先iinc在iload：

执行iinc指令，在局部变量表上对a进行+1操作，这时候a为12：

![img](https://img-blog.csdnimg.cn/20210501203855130.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70)

iload 1 将局部变量表中a=12，读取到操作数栈stack中：

![img](https://img-blog.csdnimg.cn/20210501203904630.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70)

⑤ 下面进行 a++ + ++a 操作，在操作数栈中进行相加，得到结果22，这时候第1个加法完成：

![img](https://img-blog.csdnimg.cn/20210501203911685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70)

⑥ 下面执行第二个加法（a++ + ++a）+ a--操作：

a-- 先执行 iload 命令，在执行 inc 1,-1命令，如下，先将局部变量表中的12读取到操作数栈：

![img](https://img-blog.csdnimg.cn/20210501203917797.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70)

接下来执行 inc 1,-1命令，在局部变量表中进行-1操作，此时局部变量表中的值由12减为11：

![img](https://img-blog.csdnimg.cn/20210501203927567.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70)

在操作数栈中，执行第二次加法运算，得到结果为34：

![img](https://img-blog.csdnimg.cn/20210501203935531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70)

⑦ 最后将操作数栈中的数据弹出到局部变量表中，赋值2号槽位b=34：

![img](https://img-blog.csdnimg.cn/20210501203940545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70)

## 17. JVM的几个主要组成部分

![img](https://img-blog.csdnimg.cn/20200103213149526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70)

主要由 4 个部分组成：

1. 运行时数据区域：就是我们常说的JVM的内存。
2. 执行引擎：执行 class 字节码文件中的指令。
3. 类加载系统：根据给定的全限定名类名\(如：java.lang.Object\)来装载 .class 文件到运行时数据区中的方法区中。
4. 本地接口：与本地方法库交互，是其它编程语言交互的接口。

## 18. Java会存在内存泄漏吗

会

Java中虽然存在 GC垃圾回收机制，及时回收不再被使用的对象。但是依然存在内存泄露的情况！

Java导致内存泄露的原因很明确：**长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄露**，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是Java中内存泄露的发生场景。

## 19. JVM如何确定一个类

在Java中，一个类的全名（`包名+类名`）作为其标识，但**在JVM中，一个类用其 `全名 + 类加载器`作为唯一标识**，不同类加载器加载的类置于不同的命名空间中，这叫做类加载器隔离。

## 20. new Object和包装类型，一个对象最少需要几个字节？

* 一个对象最少 _16_ 字节。

