# 操作系统篇

## 1. 进程和线程 区别

* 根本区别：进程是操作系统资源分配的基本单位，线程是任务调度和执行的基本单位
* 包含关系：一个进程最少由一条线程组成
* 所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。（时间片概念：即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片，即该进程允许运行的时间）
* 内存分配：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（**线程所使用的资源来自其所属进程的资源**），线程组之间只能共享资源。

## 2. 进程间的通信方式

* **管道**：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
* **命名管道FIFO**：未命名的管道只能在两个相关的进程之间通信，通过命名管道FIFO，不相关的进程也能交换数据。
* 消息队列：

  消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识。

  消息队列允许一个或多个进程向它写入与读取消息。

  管道和命名管道的通信数据都是先进先出原则，消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取，比FIFO更有优势。

* **共享内存**：共享内存是允许一个或多个进程共享的一块内存区域。
* **信号量**：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。通常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。

## 3. 线程间的同步方式

* 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
* 信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
* 事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

## 4. 进程的状态及其转换

进程的状态有：就绪状态、运行状态、阻塞状态。

进程状态间的转换关系为：

![img](https://img-blog.csdnimg.cn/20190220204824545.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3l1YnVqaWFuX2w=,size_16,color_FFFFFF,t_70#pic_center)

## 5. Java线程的状态

* 新建状态（New）
* 就绪状态（Runnable）
* 运行状态（Running）
* 阻塞状态（Blocked）：
  * _等待阻塞_
  * _同步阻塞_
  * _其他阻塞_
* 死亡状态（Dead）

## 6. 进程的调度算法

* **先来先服务算法**：每次调度是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。
* **短作业优先算法**：从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。
* **优先权调度算法**：1.  非抢占式优先权调度算法：系统一旦把处理机分配给优先权最高的进程后，便一直执行下去，至完成；2. 抢占式优先权调度算法：只要系统中出现一个新的就绪进程，就进行优先权比较 。若出现优先权更高的进程，则立即停止当前执行，并将处理机分配给新到的优先权最高的进程。
* **时间片轮转调度算法**：1. 时间片轮转法：先给队首进程，时间片执行完后，中断，送往队列末尾，处理机分配给队首，继续执行下去。2. 多级反馈队列调度算法：\(1\)设置多个队列，赋予不同优先级，优先级越高，时间片越小；\(2\)新进程进入内存后，先在第一队列，按照FCFS，开始执行后，如果能在该时间片内执行完，则撤离系统，否则转到第二队列末尾；\(3\)仅当第一队列空闲时，才执行第二队列，如果处理器正在第i队列服务，此时进来一个进程进入了优先级高的队列，则新进程将抢占正在运行的进程的处理机，同时把正在运行的进程丢到队列末尾。

## 7. 死锁

四个必要条件：

* 互斥：某个资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问了，直到该进程访问结束。
* 不可剥夺：进程所获得的资源在未使用完毕之前，不能被其他进程强行剥夺，只能由获得该资源使用权的进程释放资源。
* 占有且等待：一个进程请求某个资源并将其占有，即使该进程被阻塞了，也不会释放占有的资源。
* 循环等待：若干进程之间形成一种头尾相接的环形循环等待链。

预防死锁：破坏产生死锁的四个必要条件之一即可

* 强制性地从系统中撤销一个或多个死锁的进程以断开循环等待链。
* 强制性抢占死锁进程正在争取的资源以解除死锁。

## 8.进程的上下文切换

一个进程切换到另一个进程运行，称为进程的上下文切换。进程是由内核管理和调度的，所以进程的切换只能发生在内核态。

## 9.操作系统的内存管理机制了解吗？内存管理有哪几种方式？

* **块式管理**：远古时代的计算机操系统的内存管理⽅式。将内存分为⼏个固定⼤⼩的块，每 个块中只包含⼀个进程。如果程序运⾏需要内存的话，操作系统就分配给它⼀块，如果程序 运⾏只需要很⼩的空间的话，分配的这块内存很⼤⼀部分⼏乎被浪费了。这些在每个块中未 被利⽤的空间，我们称之为碎⽚。
* **⻚式管理**：把主存分为⼤⼩相等且固定的⼀⻚⼀⻚的形式，⻚᫾⼩，相对相⽐于块式管理的 划分⼒度更⼤，提⾼了内存利⽤率，减少了碎⽚。⻚式管理通过⻚表对应逻辑地址和物理地址。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。
* 段式管理：⻚式管理虽然提⾼了内存利⽤率，但是⻚式管理其中的⻚实际并⽆任何实际意 义。 段式管理把主存分为⼀段段的，每⼀段的空间⼜要⽐⼀⻚的空间⼩很多 。但是，最重 要的是段是有实际意义的，每个段定义了⼀组逻辑信息，例如,有主程序段 MAIN、⼦程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。
* 段页式管理：分页系统能有效地提高内存的利用率，而分段系统能反映程序的逻辑结构，将分页与分段结合起来，就形成了段页式管理方式。在段页式管理系统中，用户程序的逻辑地址空间首先被划分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。

## 10. CPU寻址，为什么需要虚拟地址空间

处理器使⽤的是⼀种称为**虚拟寻址**的寻址⽅式。使⽤虚拟寻址，CPU 需要**将虚拟地址翻译成物理地址**，这样才能访问到真实的物理内存。 实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有⼀个被称为**内存管理单元** 的硬件。

## 11. 什么是用户态和核心态

在计算机系统中，分两种程序：系统程序和应用程序，为了保证系统程序不被应用程序有意或无意地破坏，为计算机设置了两种状态——用户态、核心态。

* **用户态**：只能受限的访问内存，运行所有的应用程序。
* **核心态**：运行操作系统程序，CPU 可以访问内存的所有数据，包括外围设备。

## 12. I/O模型？什么是I/O多路复用

I/O请求有两个阶段：

* **等待资源阶段**：I/O请求一般需要请求特殊的资源（如磁盘、RAM、文件），当资源被上一个使用者使用没有被释放时，IO请求就会被阻塞，直到能够使用这个资源。
* **使用资源阶段**：真正进行数据接收和发送。

在等待数据阶段，I/O分为 阻塞I/O 模型 和 非阻塞I/O 模型：

* **阻塞I/O** 模型： 资源不可用时，I/O请求一直阻塞，直到反馈结果（有数据或超时）。
* **非阻塞I/O** 模型：资源不可用时，I/O请求不会被阻塞，直接返回数据标识资源不可用。但是进程会不停的去轮询检测资源是否可用。

在使用资源阶段，I/O分为 同步I/O 模型 和 异步I/O 模型：

* **同步I/O** 模型：应用阻塞在发送或接收数据的状态，直到数据成功传输或返回失败结果。
* **异步I/O** 模型：应用发送或接收数据后立刻返回，数据写入操作系统缓存，由操作系统完成数据发送或接收，并返回成功或失败的信息给应用。

**I/O多路复用**（I/O复用模型）：

* I/O 多路复用可以同时阻塞多个I/O操作，而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写。

## 13. 什么是生产者消费者模型？

生产者：

* 在操作系统中，生产者生产一条数据，首先查看缓冲区能否放入数据，有没有空的位置，如果有往下执行，否则说明缓冲区全满了，消费者还没有及时的来消费数据。这时候生产者会进入阻塞等待（会唤醒消费者去消费数据）。
* 同样的，假设**多个**生产者都已经申请到执行权时，此时只能有一个生产者可以进入生产状态，所以其他几个生产者又要被阻塞一次。

消费者：

* 消费者消费一条数据时，首先查看缓冲区是否有数据单元，如果有执行消费，否则消费者进入阻塞等待（会唤醒生产者去生产数据）。

