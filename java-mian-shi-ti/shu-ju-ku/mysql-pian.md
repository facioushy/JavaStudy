# Mysql篇

## 1. 数据库优化

![&#x5728;&#x8FD9;&#x91CC;&#x63D2;&#x5165;&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://img-blog.csdnimg.cn/20210604211235657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzkwNTQ1,size_16,color_FFFFFF,t_70#pic_center)

* 高：从SQL优化、索引优化入手，优化慢SQL、利用好索引，是重中之重；
* 中：SQL优化之后，是对数据表结构设计、横纵分表分库，对数据量级的处理；
* 低：通过修改数据库系统配置，最大化里用服务器内存等资源；
* 低：通过以上方式还不行，那就是服务器资源瓶颈了，加机器。

### SQL优化的技巧

简单说对于SQL优化，就三点:

* 最大化利用索引；
* 尽可能避免全表扫描；
* 减少无效数据的查询；

#### SQL优化策略

1. 尽量避免在字段开头模糊查询，会导致数据库引擎放弃索引进行全表扫描。如下：

```sql
SELECT * FROM t WHERE username LIKE '%陈%'
```

优化方式：尽量在字段后面使用模糊查询。如下

```sql
SELECT * FROM t WHERE username LIKE '陈%'
```

如果需求是要在前面使用模糊查询，

* 使用MySQL内置函数INSTR\(str,substr\) 来匹配，作用类似于java中的indexOf\(\)，查询字符串出现的角标位置
* 使用FullText全文索引，用match against 检索
* 数据量较大的情况，建议引用ElasticSearch、solr，亿级数据量检索速度秒级
* 尽量避免使用or，会导致数据库引擎放弃索引进行全表扫描。如下：

```sql
SELECT * FROM t WHERE id = 1 OR id = 3
```

优化方式：可以用union代替or。如下：

```sql
SELECT * FROM t WHERE id = 1
   UNION
SELECT * FROM t WHERE id = 3
```

1. 尽量避免进行null值的判断，会导致数据库引擎放弃索引进行全表扫描。如下：

```sql
SELECT * FROM t WHERE score IS NULL
```

优化方式：可以给字段添加默认值0，对0值进行判断。如下：

```sql
SELECT * FROM t WHERE score = 0
```

1. 尽量避免在where条件中等号的左侧进行表达式、函数操作，会导致数据库引擎放弃索引进行全表扫描。

可以将表达式、函数操作移动到等号右侧。如下：

```sql
-- 全表扫描
SELECT * FROM T WHERE score/10 = 9
-- 走索引
SELECT * FROM T WHERE score = 10*9
```

1. 当数据量大时，避免使用where 1=1的条件。通常为了方便拼装查询条件，我们会默认使用该条件，数据库引擎会放弃索引进行全表扫描。如下：

```sql
SELECT username, age, sex FROM T WHERE 1=1
```

1. 查询条件不要用 &lt;&gt; 或者 !=

使用索引列作为条件进行查询时，需要避免使用&lt;&gt;或者!=等判断条件。如确实业务需要，使用到不等于符号，需要在重新评估索引建立，避免在此字段上建立索引，改由查询条件中其他索引字段代替。

1. where条件仅包含复合索引非前置列

如下：复合（联合）索引包含key\_part1，key\_part2，key\_part3三列，但SQL语句没有包含索引前置列"key\_part1"，按照MySQL联合索引的最左匹配原则，不会走联合索引。。

```sql
select col1 from table where key_part2=1 and key_part3=2
```

1. 隐式类型转换造成不使用索引

如下SQL语句由于索引对列类型为varchar，但给定的值为数值，涉及隐式类型转换，造成不能正确走索引。

```sql
select col1 from table where col_varchar=123;
```

1. order by 条件要与where中条件一致，否则order by不会利用索引进行排序

```sql
-- 不走age索引
SELECT * FROM t order by age;

-- 走age索引
SELECT * FROM t where age > 0 order by age;
对于上面的语句，数据库的处理顺序是：
```

第一步：根据where条件和统计信息生成执行计划，得到数据。 第二步：将得到的数据排序。当执行处理数据（order by）时，数据库会先查看第一步的执行计划，看order by 的字段是否在执行计划中利用了索引。如果是，则可以利用索引顺序而直接取得已经排好序的数据。如果不是，则重新进行排序操作。 第三步：返回排序后的数据。

这个结论不仅对order by有效，对其他需要排序的操作也有效。比如group by 、union 、distinct等。

#### SELECT语句的一些其他优化

1. 避免使用select \*

使用select \* 取出全部列，会让优化器无法完成索引覆盖扫描这类优化，会影响优化器对执行计划的选择，也会增加网络带宽消耗，更会带来额外的I/O,内存和CPU消耗。

建议提出业务实际需要的列数，将指定列名以取代select \*。

1. 避免出现不确定结果的函数

特定针对主从复制这类业务场景。由于原理上从库复制的是主库执行的语句，使用如now\(\)、rand\(\)、sysdate\(\)、current\_user\(\)等不确定结果的函数很容易导致主库与从库相应的数据不一致。另外不确定值的函数,产生的SQL语句无法利用query cache。

1. `多表关联查询时，小表在前，大表在后`

在MySQL中，执行 from 后的表关联查询是从左往右执行的（Oracle相反），第一张表会涉及到全表扫描，所以将小表放在前面，先扫小表，扫描快效率较高，在扫描后面的大表，或许只扫描大表的前100行就符合返回条件并return了。

1. `使用表的别名`

当在SQL语句中连接多个表时，请使用表的别名并把别名前缀于每个列名上。这样就可以减少解析的时间并减少哪些友列名歧义引起的语法错误。

1. `用where字句替换HAVING字句`

避免使用HAVING字句，因为HAVING只会在检索出所有记录之后才对结果集进行过滤，而where则是在聚合前刷选记录，如果能通过where字句限制记录的数目，那就能减少这方面的开销。HAVING中的条件一般用于聚合函数的过滤，除此之外，应该将条件写在where字句中。

where和having的区别：where后面不能使用组函数

1. `调整Where字句中的连接顺序`

MySQL采用从左往右，自上而下的顺序解析where子句。根据这个原理，应将过滤数据多的条件往前放，最快速度缩小结果集。对了，听说5.7版的语法解析器已经实现了where后条件的自动调节工作。查询条件很多的场景，建议不要做这种尝试。

## 2. 怎么看分库分表

* 分库：由单个数据库实例拆分成多个数据库实例，将数据分布到多个数据库实例中。
* 分表：由单张表拆分成多张表，将数据划分到多张表内。

常用策略包括：`垂直分表`、`水平分表`、`垂直分库`、`水平分库`。

![&#x5728;&#x8FD9;&#x91CC;&#x63D2;&#x5165;&#x56FE;&#x7247;&#x63CF;&#x8FF0;](https://img-blog.csdnimg.cn/20210604212308837.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5MzkwNTQ1,size_16,color_FFFFFF,t_70#pic_center)

### 分表

#### 1. 垂直分表

* 每个表的结构都不一样；
* 每个表的数据也不一样，
* 有一个关联字段，一般是主键或外键，用于关联`兄弟表`数据；
* 所有兄弟表的并集是该表的全量数据；

使用场景：

* 有几个字段属于热点字段，更新频率很高，要把这些字段单独切到一张表里，不然innodb行锁很恶心的，锁死你呀~~如用户表里的余额字段
* 有大字段，如text，存储压力很大，毕竟innodb数据和索引是同一个文件；同时，我又喜欢用SELECT \*，你懂得，这磁盘IO消耗的，跟玩儿似的，谁都扛不住的。
* 有明显的业务区分，或表结构设计时字段冗余；

#### 2. 水平分表

* 每个表的结构都一样；
* 每个表的数据都不一样，没有交集；
* 所有表的并集是该表的全量数据；

使用场景：

* 如手机号表，我们可以通过前两位或前三位进行切分，如`131、132、133 → phone_131、phone_132、phone_133`，手机号有11位（100亿），量大是很正常的事儿，这年头谁家老头老太太每个手机呢是吧。这样切就把一张大表切成了好几十张小表，数据量不就下来了
* 单表的数据量过大或增长速度很快，已经影响或即将会影响SQL查询效率，加重了CPU负担，提前到达瓶颈。

### 分库

需要你注意的是，传统的分库和我们熟悉的集群、主从复制可不是一个事儿；多节点集群是将一个库复制成N个库，从而通过读写分离实现多个MySQL服务的负载均衡，实际是围绕一个库来搞的，这个库称为Master主库。而分库就不同了，分库是将这个主库一分为N，比如一分为二，然后针对这两个主库，再配置2N个从库节点。

#### 1. 垂直分库

纵向切库，太经典的切分方式，基于表进行切分，通常是把新的业务模块或集成公共模块拆分出去，比如我们最熟悉的单点登录、鉴权模块。

* 每个库的表都不一样；
* 表不一样，数据就更不一样了~ 没有任何交集；
* 每个库相对独立，模块化

使用场景：可以抽象出单独的业务模块时，可以抽象出公共区时（如字典、公共时间、公共配置等）

#### 2. 水平分库

以行数据为依据，将一个库中的数据拆分到多个库中。大型分表体验一下？坦白说这种策略并不实用，因为会对后台开发很不友好，有很多坑，不建议采用，理解即可。

特点：

* 每个库的结构都一样；
* 每个库的数据都不一样，没有交集；
* 所有库的并集是全量数据；

使用场景：系统绝对并发量上来了，CPU内存压力大。分表难以根本上解决量的问题，并且还没有明显的业务归属来垂直分库，主库磁盘接近饱和。

PS: 其实，在实际工作中，我们在选择分库分表策略前，想到的应该是从缓存、读写分离、SQL优化等方面，因为这些能够更直接、代价更小的解决问题。`要记住动表就是动根本，你永远不知道这张表后面会连带多少历史遗留问题`

## 3. Mysql删除数据的方式有哪些

delete、truncate、drop

### 区别

#### 执行速度：

drop &gt; truncate &gt;&gt; DELETE

#### 原理：

* Delete

只删除数据不删除表的结构，会走事务

在 InnoDB 中，DELETE其实并不会真的把数据删除，mysql 实际上只是给删除的数据打了个标记为已删除，因此 delete 删除表中的数据时，表文件在磁盘上所占空间不会变小，存储空间不会被释放，只是把删除的数据行设置为不可见。虽然未释放磁盘空间，但是下次插入数据的时候，仍然可以重用这部分空间（重用 → 覆盖）。

delete 操作是一行一行执行删除的，并且同时将该行的的删除操作日志记录在redo和undo表空间中以便进行回滚（rollback）和重做操作，生成的大量日志也会占用磁盘空间。

* truncate

不走事务。执行后立即生效，无法找回

立刻释放磁盘空间

truncate能够快速清空一个表。并且重置auto\_increment的值。

* drop

执行后立即生效，无法找回

可以这么理解，一本书，delete是把目录撕了，truncate是把书的内容撕下来烧了，drop是把书烧了

## 4. 最左匹配原则

索引abc\_index:\(a,b,c\)，只会在where条件中带有\(a\)、\(a,b\)、\(a,b,c\)的三种类型的查询中使用。

### 原理

假设数据 表 LOL \(id,sex,price,name\) 的物理位置（表中的无序数据）如下：

```sql
主键id  sex(a)   price(b)      name(c)    
(1)     1         1350         AAA安妮
(2)     2         6300         MMM盲僧
(3)     1         3150         NNN奈德丽
(4)     2         6300         CCC锤石
(5)     1         6300         LLL龙女
(6)     2         3150         EEE伊泽瑞尔
(7)     2         6300         III艾克
(8)     1         6300         BBB暴走萝莉
(9)     1         4800         FFF发条魔灵
(10)    2         3150         KKK卡牌大师
(11)    1         450          HHH寒冰射手
(12)    2         450          GGG盖伦
(13)    2         3150         OOO小提莫
(14)    2         3150         DDD刀锋之影
(15)    2         6300         JJJ疾风剑豪
(16)    2         450          JJJ剑圣
```

当你在LOL表创建一个联合索引 abc\_index:\(sex,price,name\)时，生成的`索引文件逻辑上等同于下表内容（分级排序）`：

```sql
sex(a)   price(b)       name(c)         主键id
1        450            HHH寒冰射手      (11)
1        1350           AAA安妮          (1)
1        3150           NNN奈德丽        (3)
1        4800           FFF发条魔灵       (9)
1        6300           BBB暴走萝莉       (8)
1        6300           LLL龙女          (5)
2        450            GGG盖伦          (12)
2        450            JJJ剑圣          (16)
2        3150           DDD刀锋之影       (14)
2        3150           EEE伊泽瑞尔       (6)
2        3150           KKK卡牌大师       (10)
2        3150           OOO小提莫         (13)
2        6300           CCC锤石          (4)
2        6300           III艾克          (7)
2        6300           JJJ疾风剑豪       (15)
2        6300           MMM盲僧          (2)
```

B+ 树会优先比较 sex 来确定下一步的指针所搜方向，如果 sex 相同再依次比较 price 和 name，最后得到检索的数据；

### 违背最左原则导致索引失效的情况

以联合索引 abc\_index:\(a,b,c\) 来进行讲解

1. 确实优先级最高的索引"a"

当 where b = 6300 and c = 'JJJ疾风剑豪' 这种没有以 a 为条件来检索时；B+树就不知道第一步该查哪个节点，从而需要去全表扫描了（即不走索引）。因为建立搜索树的时候 a 就是第一个比较因子，必须要先根据 a 来搜索，进而才能往后继续查询b 和 c，这点我们通过上面的存储结构图可以看明白。

1. **查询条件中，缺失优先级居中的索引 “b”**

当 where a =1 and c =“JJJ疾风剑豪” 这样的数据来检索时；B+ 树可以用 a 来指定第一步搜索方向，但由于下一个字段 b 的缺失，所以只能把 a = 1 的数据主键ID都找到，通过查到的主键ID回表查询相关行，再去匹配 c = ‘JJJ疾风剑豪’ 的数据了，当然，这至少把 a = 1 的数据筛选出来了，总比直接全表扫描好多了。

### 查询优化器做了什么

1. **如果建的索引顺序是 \(a, b\)。而查询的语句是 where b = 1 AND a = ‘XXX’; 为什么还能利用到索引？**

   理论上索引对顺序是敏感的，但是由于 MySQL 的查询优化器会自动调整 where 子句的条件顺序以使用适合的索引

2. **还有一个特殊情况说明下，下面这种类型的SQL， a 与 b 会走索引，c不会走。**

```sql
select * from LOL where a = 2 and b > 1000  and c='JJJ疾风剑豪';
```

对于上面这种类型的sql语句；mysql会一直向右匹配直到遇到范围查询\(&gt;、&lt;、between、like\)就停止匹配（包括like '陈%'这种）。在a、b走完索引后，c已经是无序了，所以c就没法走索引，优化器会认为还不如全表扫描c字段来的快。所以只使用了\(a,b\)两个索引，影响了执行效率。

其实，这种场景可以通过修改索引顺序为 abc\_index:\(a,c,b\)，就可以使三个索引字段都用到索引

## 5. 覆盖索引的好处

如果一个索引包含所有需要的查询的字段的值，我们称之为覆盖索引。覆盖索引是非常有用的工具，能够极大的提高性能。因为，只需要读取索引，而无需读表，极大减少数据访问量，这也是不建议使用Select \* 的原因。

